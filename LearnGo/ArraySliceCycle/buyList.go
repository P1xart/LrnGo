// Создан для изучения массивов (списков), срезов и цикла for для массивов.
package main

import "fmt"

func main() {
	var buyList = [...]string{ // Массив. string - тип ВСЕХ элементов в списке.
		"Breed",			   // [...] - означают произвольное (явно не указанное) кол-во элементов в массиве.
		"Fish",				   // Список является строго типизированным и фиксированным по длине элементом.
		"Good",				   // Можно изменять или оставлять на время элементы в массиве пустыми, если его длинна указана явно.
	}
	buyList[1] = "Tomato" // Индексация индентична python, как и многим другим языкам.
	fmt.Printf("Кол-во продуктов в списке - %d\n", len(buyList))
	for index := range buyList { // Конструкция for - for переменная; условие; операция {}, имеет другие конструкции.
								 // Конструкция range проходится по списку от 0 и до конца списка.
		fmt.Printf("%d. %s\n", index+1, buyList[index])
	}
	fmt.Println()
	var sliceList = []string{ // Срез. Тот же массив, но без фиксированной длинны. Имеет неявный указатель на массив.
		"Станцевать",		  // [] - в отличии от массива всегда пусты.
		"Покурить",			  // Список имеет ёмкость и длинну, ёмкость измеряется cap() и длинна len() соответственно.
		"Похлопать",		  // append(slice []Type, elems ...Type) []Type позволяет добавлять в срез новые элементы, изменяя емкость и длинну, возвращает новый массив.
		"Сбегать",
	}
	fmt.Printf("Емкость среза = %d\nДлинна среза = %d\n", cap(sliceList), len(sliceList))
	sliceList = append(sliceList, "Зафлексить")
	fmt.Printf("Добавлен новый элемент.\nЕмкость среза после = %d\nДлинна среза после = %d\n", cap(sliceList), len(sliceList))
}
